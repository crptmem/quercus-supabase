CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "avatar" "text" DEFAULT '''https://fezquqpzqprwydeocyvo.supabase.co/storage/v1/object/public/defaults/defavatar.png''::text'::"text" NOT NULL,
    "displayname" "text" DEFAULT ''::"text",
    "bgimage" "text" DEFAULT ''::"text" NOT NULL
);

ALTER TABLE "public"."profiles" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."append_entry"("user_id" "uuid", "entry" "jsonb") RETURNS "public"."profiles"
    LANGUAGE "sql"
    AS $$
  update profiles
  set entries = coalesce(entries, '[]'::jsonb) || entry
  where id = user_id
  returning *;
$$;

ALTER FUNCTION "public"."append_entry"("user_id" "uuid", "entry" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."change_user_password"("current_plain_password" character varying, "new_plain_password" character varying) RETURNS "json"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
_uid uuid; -- for checking by 'is not found'
user_id uuid; -- to store the user id from the request
BEGIN
  -- First of all check the new password rules
  -- not empty
  IF (new_plain_password = '') IS NOT FALSE THEN
    RAISE EXCEPTION 'New password is empty';
  -- minimum 6 chars
  ELSIF char_length(new_plain_password) < 6 THEN
    RAISE EXCEPTION 'Password must be at least 6 characters in length';
  END IF;
  
  -- Get user by his current auth.uid and current password
  user_id := auth.uid();
  SELECT id INTO _uid
  FROM auth.users
  WHERE id = user_id
  AND encrypted_password =
  crypt(current_plain_password::text, auth.users.encrypted_password);

  -- Check the currect password
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Incorrect password';
  END IF;

  -- Then set the new password
  UPDATE auth.users SET 
  encrypted_password =
  crypt(new_plain_password, gen_salt('bf'))
  WHERE id = user_id;
  
  RETURN '{"data":true}';
END;
$$;

ALTER FUNCTION "public"."change_user_password"("current_plain_password" character varying, "new_plain_password" character varying) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."delete_shared_entries"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  DELETE FROM public.entries
  WHERE user_id = NEW.user_id AND user_id IN (SELECT id FROM auth.users WHERE email = NEW.shared_to);
  RETURN NEW;
END;
$$;

ALTER FUNCTION "public"."delete_shared_entries"() OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."entries" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "glucose" double precision,
    "insulin" bigint,
    "grainunits" bigint,
    "carbohydrates" bigint,
    "food" "text",
    "timestamp" "text" DEFAULT "to_char"((CURRENT_DATE)::timestamp with time zone, 'DD/MM/YYYY'::"text"),
    "unix_timestamp" bigint DEFAULT EXTRACT(epoch FROM "now"())
);

ALTER TABLE "public"."entries" OWNER TO "postgres";

ALTER TABLE "public"."entries" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."entries_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."shares" (
    "user_id" "uuid" NOT NULL,
    "shared_to" "text",
    "my_email" "text",
    "id" bigint NOT NULL
);

ALTER TABLE "public"."shares" OWNER TO "postgres";

ALTER TABLE "public"."shares" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."shares_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE ONLY "public"."entries"
    ADD CONSTRAINT "entries_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."shares"
    ADD CONSTRAINT "shares_id_key" UNIQUE ("id");

ALTER TABLE ONLY "public"."shares"
    ADD CONSTRAINT "shares_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."entries"
    ADD CONSTRAINT "entries_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."shares"
    ADD CONSTRAINT "shares_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

CREATE POLICY "Allow delete their own entries" ON "public"."entries" FOR DELETE USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Enable delete for users based on user_id" ON "public"."shares" FOR DELETE USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Enable insert for users based on user_id" ON "public"."shares" FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable read access for all users" ON "public"."shares" FOR SELECT USING (true);

CREATE POLICY "Entries are viewable by users who created them." ON "public"."entries" FOR SELECT USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Profiles are viewable by users who created them." ON "public"."profiles" FOR SELECT USING (("auth"."uid"() = "id"));

CREATE POLICY "Users can insert their own entries." ON "public"."entries" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));

CREATE POLICY "Users can insert their own profile." ON "public"."profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "id"));

CREATE POLICY "Users can update own entries." ON "public"."entries" FOR UPDATE USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Users can update own profile." ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "id"));

CREATE POLICY "allow_shared_entries" ON "public"."entries" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."shares"
  WHERE (("shares"."user_id" = "entries"."user_id") AND ("shares"."shared_to" = ("auth"."jwt"() ->> 'email'::"text"))))));

CREATE POLICY "allow_shared_entries_insert" ON "public"."entries" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."shares"
  WHERE (("shares"."user_id" = "entries"."user_id") AND ("shares"."shared_to" = ("auth"."jwt"() ->> 'email'::"text"))))));

CREATE POLICY "delete_entries_policy1" ON "public"."entries" FOR DELETE USING ((EXISTS ( SELECT "shares"."user_id"
   FROM "public"."shares"
  WHERE ("shares"."shared_to" = ( SELECT ("auth"."jwt"() ->> 'email'::"text"))))));

ALTER TABLE "public"."entries" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."shares" ENABLE ROW LEVEL SECURITY;
